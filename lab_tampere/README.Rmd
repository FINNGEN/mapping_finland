---
title: "lab_tampere"
output:
  github_document:
    toc: true
    df_print: kable
#   html_document:
#     df_print: paged
#     toc: true
---

```{r setup, include=FALSE}
rm(list = ls())

knitr::opts_chunk$set(echo = FALSE)

library(tidyverse)
library(scales)


getOutputFormat <- function() {
  output <- rmarkdown:::parse_yaml_front_matter(
    readLines(knitr::current_input())
    )$output
  if (is.list(output)){
    return(names(output)[1])
  } else {
    return(output[1])
  }
}


# Dynamic markdown functions
my_print_line<- function(...){
  cat(str_c(" \n",...," \n"))
}

my_print_table<- function(...){
  if(getOutputFormat() == 'html_document') {
   cat(knitr::knit_print(rmarkdown::paged_table(...)))
  }else{
    cat(knitr::knit_print(knitr::kable(...)))
  }
  
}

# Document variables 
N_TOPS <- 10

# output status
db_statuses <- tibble()

```

```{r load, message=FALSE, warning=FALSE}
lab_tampere_source_vocabulary <- read_csv("./1_source_vocabulary/lab_tampere_for_source_vocabulary.csv")

lab_tampere_freqs <- read_csv("./3_freq_of_source_codes/freq_total.csv")


col_types = cols( .default = col_character(), 
                  sourceFrequency = col_integer(),
                  matchScore  = col_integer(),
                  conceptId  = col_integer()
                  )

lab_tampere_after_usagi <- read_csv("./2_mapping_to_standard/USAGI/lab_tampere_after_usagi.csv", col_types = col_types) # cant get the encoding rigth
```


# Intro
TODO

# Formating source vocabulary to OMOP
TODO

```{r}
lab_tampere_source_vocabulary %>% count(name_en_source)
```

Source table with added translation has been formatted to be similar to OMOP in  [1_source_vocabulary/lab_tampere_for_source_vocabulary.csv](1_source_vocabulary/lab_tampere_for_source_vocabulary.csv). 


# Mapping the source vocabulary to the standard vocabularies
In short, USAGI 

TODO 

Mapping was carried by medical student [\@kalleaseppala](github.com/kalleaseppala) and reviewed by [\@helmisuominen](github.com/helmisuominen). 


## Progess in number of codes
```{r}
n_codes <- lab_tampere_after_usagi %>% distinct(sourceCode) %>% nrow()
n_codes_accepted <- lab_tampere_after_usagi %>% filter(mappingStatus=="APPROVED") %>% distinct(sourceCode) %>% nrow()
```


From `r scales::number(n_codes)` codes `r scales::number(n_codes_accepted)` have been approved. 

This makes `r scales::percent(n_codes_accepted/n_codes)` of codes approved. 


```{r}
lab_tampere_after_usagi %>% distinct(sourceCode, mappingStatus) %>% count(mappingStatus)
```

```{r}
a <- lab_tampere_after_usagi %>% distinct(sourceCode, mappingStatus, sourceFrequency)

n_total_envents <- sum(a$sourceFrequency)
n_approved_events <- a %>% filter(mappingStatus=="APPROVED") %>% .$sourceFrequency %>% sum()

max_n_events_unmapped <-  a %>% filter(mappingStatus=="UNCHECKED") %>% .$sourceFrequency %>%  max()
```

## Progess in number of events

Accepted codes covers `r scales::percent(n_approved_events/n_total_envents)` of the total number of events in the combined databases. 

Accepted codes covers all codes with more than `r scales::number(max_n_events_unmapped)` events in the combined databases.

Top`r N_TOPS` of the unchecked events sort by number of events : 

```{r}
lab_tampere_after_usagi %>% filter(mappingStatus=="UNCHECKED") %>% arrange(-sourceFrequency) %>% select(sourceCode,  sourceFrequency, matchScore, sourceName, `ADD_INFO:Pitkä.nimi`) %>%  head(N_TOPS)
```

```{r}
db_statuses <- bind_rows(
  tibble(
    status = "mapped",
    n_codes = n_codes_accepted,
    per_codes = percent(n_codes_accepted/!!n_codes),
    n_events = n_approved_events,
    per_events = percent(n_approved_events/n_total_envents), 
    db_name = "source"
  ),
 tibble(
    status = "not_mapped",
    n_codes = !!n_codes-n_codes_accepted,
    per_codes = percent((!!n_codes-n_codes_accepted)/!!n_codes),
    n_events = n_total_envents-n_approved_events,
    per_events = percent((n_total_envents-n_approved_events)/n_total_envents), 
    db_name = "source"
  )
)
```



# Assessing coverage of databases


```{r  results='asis'}
# get database names from freq tables 
db_names <- lab_tampere_freqs %>% names %>% setdiff(c("code", "code_abr", "freq_total")) %>% str_replace("freq_","")

#for each data base
for(db_name in db_names){
#assess_db <- function(i){
 # db_name <- db_names[i]

  # get only preset dtabase info 
  db_freq <- lab_tampere_freqs %>% 
    select(code, code_abr, str_c("freq_",db_name)) %>% 
    rename(freq = str_c("freq_",db_name)) %>% 
    filter(!is.na(freq))
  
  n_total_envents <- sum(db_freq$freq)
  
  # join with usagi output #### code_abr!!###
  db_join <- left_join(
    db_freq,
    lab_tampere_after_usagi %>% rename(code_abr=sourceCode, name_en=sourceName, name_fi=`ADD_INFO:Pitkä.nimi`) %>% 
      select(code_abr, name_en, name_fi, mappingStatus ), 
    by = "code_abr") %>%
  mutate( freq_per=percent(freq/n_total_envents, accuracy = 0.001)) %>% 
    arrange(-freq)
  
  #save not found codes
  db_missing <- db_join %>% filter(is.na(mappingStatus)) %>% select(code, freq, freq_per)
  save_db_missing_path <- str_c("./3_freq_of_source_codes/",db_name,"_not_in_lab_tampere.csv")
  write_csv(db_missing, save_db_missing_path )
  
  # calculate status count
  db_status <- db_join %>% 
    mutate(status = case_when( 
      is.na(mappingStatus) ~ "not_found",  
      mappingStatus == "UNCHECKED" ~ "not_mapped", 
      TRUE ~ "mapped"
    )
  ) %>% 
  mutate(status = factor(status, levels = c("mapped", "not_mapped",  "not_found"))) %>% 
  group_by(status) %>% 
  summarise(n_codes=n(), 
            per_codes= percent(n_codes/nrow(.), accuracy = 0.001),
            n_events = sum(freq), 
            per_events= percent(n_events/sum(.$freq), accuracy = 0.001), 
            .groups = 'drop')
  
  db_statuses <- bind_rows(db_statuses, db_status %>% mutate(db_name = db_name))
  
   # plot markdown 
  my_print_line()
  my_print_line("## Database ", db_name)
  
  my_print_line("**How many codes labeled as lab_tampere in ", db_name," are not in the lab_tampere standard?**")
  
  my_print_line("There are ", scales::number(db_missing %>% nrow())," codes not found in the standard")
  
  my_print_line("Top", N_TOPS," sort by freq:")
  
  my_print_table(db_missing %>% head(N_TOPS))
  
  my_print_line("The full list can be found in [",save_db_missing_path,"](",save_db_missing_path,")")
  
 
  my_print_line("**Status of the lab_tampere codes in", db_name, "**")
  
  my_print_table(db_status)
  
  
}


write_csv(db_statuses, "status_table.csv" )
  

```




















